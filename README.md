# üç∑ Vinheria Agnello IoT Monitor: Adega Inteligente üå°Ô∏èüíßüí°

<p align="center">
  <img src="https://i.imgur.com/your-image-url.png" alt="Montagem do Projeto IoT Vinheria Agnello" width="700"/>
</p>

**Tagline:** _Monitoramento em tempo real de temperatura, umidade e luz para garantir a qualidade perfeita dos seus vinhos._

---

<p align="center">
  <img src="https://img.shields.io/badge/ESP32-purple?style=for-the-badge&logo=espressif" alt="Hardware ESP32">
  <img src="https://img.shields.io/badge/MQTT-red?style=for-the-badge&logo=mqtt" alt="Protocolo MQTT">
  <img src="https://img.shields.io/badge/Python-blue?style=for-the-badge&logo=python" alt="Backend Python">
  <img src="https://img.shields.io/badge/Flask-black?style=for-the-badge&logo=flask" alt="Framework Flask">
  <img src="https://img.shields.io/badge/Wokwi-cyan?style=for-the-badge" alt="Simulado no Wokwi">
</p>

---

## üìñ Sobre o Projeto

O **Vinheria Agnello IoT Monitor** √© um sistema inteligente projetado para monitorar as condi√ß√µes ambientais cruciais dentro de uma adega de vinhos. Utilizando um microcontrolador **ESP32** conectado a sensores de **temperatura e umidade (DHT11/DHT22)** e **luminosidade (LDR)**, o sistema coleta dados vitais em tempo real.

**Por que isso √© importante?** A qualidade e o envelhecimento do vinho s√£o extremamente sens√≠veis a varia√ß√µes de temperatura, umidade e exposi√ß√£o √† luz. Manter essas condi√ß√µes est√°veis √© essencial para preservar o sabor, o aroma e as propriedades da bebida.

**Como funciona?**

1.  O **ESP32** l√™ os dados dos sensores.
2.  Conecta-se √† rede **Wi-Fi** local.
3.  Envia os dados (com timestamp) para um servidor central (Broker MQTT) usando o protocolo leve **MQTT**.
4.  Um **aplicativo backend em Python** (usando Flask e Paho-MQTT) "escuta" essas mensagens do Broker MQTT.
5.  O backend processa os dados e os envia em tempo real para um **dashboard web**, permitindo a visualiza√ß√£o f√°cil e imediata das condi√ß√µes da adega.

Este projeto foi desenvolvido como parte das atividades acad√™micas na **FIAP**, demonstrando a aplica√ß√£o pr√°tica de conceitos de Internet das Coisas (IoT), comunica√ß√£o de rede, desenvolvimento de hardware embarcado (ESP32/Arduino) e backend (Python/Flask).

---

## ‚ú® Funcionalidades Principais

- üå°Ô∏è **Leitura de Temperatura e Umidade:** Utiliza o sensor DHT11 ou DHT22 para medi√ß√µes precisas.
- üí° **Leitura de Luminosidade:** Usa um sensor LDR para monitorar a intensidade da luz.
- üì∂ **Conectividade Wi-Fi:** O ESP32 conecta-se √† rede local para enviar os dados.
- üì° **Comunica√ß√£o MQTT:** Envio eficiente dos dados dos sensores para um broker MQTT central.
- üïí **Timestamping:** Cada leitura de sensor inclui data e hora exatas.
- üêç **Backend Python/Flask:** Recebe os dados via MQTT, processa e disponibiliza para o frontend.
- üìä **Dashboard Web em Tempo Real:** Interface simples (criada com Flask e Socket.IO) que exibe os dados dos sensores instantaneamente no navegador.
- ‚ú® **Convers√£o para Porcentagem:** A luminosidade √© convertida e exibida em um formato intuitivo de porcentagem (0-100%).

---

## üì∏ Telas (Exemplos)

- **Montagem no Wokwi:** Visualiza√ß√£o da conex√£o dos componentes na simula√ß√£o.
  <img src="https://i.imgur.com/your-wokwi-image.png" alt="Simula√ß√£o do Projeto no Wokwi" width="700"/>
- **Dashboard Web:** Como os dados s√£o exibidos no navegador.
  <img src="https://i.imgur.com/your-dashboard-image.png" alt="Dashboard Web com dados dos sensores" width="700"/>

> **Nota:** Substitua as URLs de exemplo (`https://i.imgur.com/...`) pelos links das suas pr√≥prias imagens.

---

## üõ†Ô∏è Tecnologias Utilizadas

| Categoria       | Tecnologia                                                                                                                                                                                                                                                                                                                    | Descri√ß√£o                                                            |
| :-------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------- |
| **Hardware**    | <img src="https://img.shields.io/badge/ESP32-purple?logo=espressif" alt="ESP32"> <img src="https://img.shields.io/badge/DHT22-blue" alt="DHT Sensor"> <img src="https://img.shields.io/badge/LDR-orange" alt="LDR Sensor">                                                                                                    | Microcontrolador com Wi-Fi e sensores de ambiente.                   |
| **Firmware**    | <img src="https://img.shields.io/badge/Arduino%20C++-00979D?logo=arduino" alt="Arduino C++">                                                                                                                                                                                                                                  | C√≥digo embarcado no ESP32 para leitura e envio de dados.             |
| **Comunica√ß√£o** | <img src="https://img.shields.io/badge/MQTT-red?logo=mqtt" alt="MQTT"> <img src="https://img.shields.io/badge/Wi--Fi-blue" alt="Wi-Fi">                                                                                                                                                                                       | Protocolo para envio de dados IoT e conex√£o de rede sem fio.         |
| **Backend**     | <img src="https://img.shields.io/badge/Python-blue?logo=python" alt="Python"> <img src="https://img.shields.io/badge/Flask-black?logo=flask" alt="Flask"> <img src="https://img.shields.io/badge/Socket.IO-grey?logo=socketdotio" alt="Socket.IO"> <img src="https://img.shields.io/badge/Paho--MQTT-yellow" alt="Paho-MQTT"> | Recebe dados via MQTT e os serve para o dashboard web em tempo real. |
| **Simula√ß√£o**   | <img src="https://img.shields.io/badge/Wokwi-cyan" alt="Wokwi">                                                                                                                                                                                                                                                               | Plataforma online para simular o circuito e o c√≥digo do ESP32.       |

---

## üèóÔ∏è Arquitetura Simplificada

O fluxo de dados no sistema √© o seguinte:

1.  **Sensores (DHT & LDR)** capturam os dados do ambiente.
2.  O **ESP32** l√™ os sensores, adiciona um timestamp e publica os dados via **MQTT**.
3.  O **Broker MQTT** (um servidor na nuvem, como HiveMQ ou Mosquitto) recebe os dados.
4.  O **Backend Python (Flask)**, que est√° inscrito no t√≥pico MQTT, recebe os dados do broker.
5.  O Backend envia os dados via **Socket.IO** para o navegador do usu√°rio.
6.  O **Dashboard Web** (HTML/JavaScript no navegador) exibe os dados em tempo real.


# üå°Ô∏èüíßüí° IoT com ESP32 + MQTT + Flask + Dashboard Web

## üìä Vis√£o Geral do Projeto

O projeto conecta sensores f√≠sicos a um **ESP32**, que envia dados via **MQTT** para um **Backend Python/Flask**, exibindo as leituras em tempo real em um **Dashboard Web**.

### üîó Fluxo de Comunica√ß√£o

```mermaid
graph LR;
    Sensores[üå°Ô∏èüíßüí° Sensores DHT/LDR] -->|Leitura| ESP32[üíª ESP32];
    ESP32 -->|Wi-Fi| BrokerMQTT[‚òÅÔ∏è Broker MQTT];
    BrokerMQTT -->|Subscri√ß√£o| Backend[üêç Backend Python/Flask];
    Backend -->|Socket.IO| Dashboard[üìä Dashboard Web];
    Dashboard -->|Visualiza√ß√£o| Usuario[üë©‚Äçüíª Usu√°rio];

    style Sensores fill:#f9f,stroke:#333,stroke-width:2px;
    style ESP32 fill:#ccf,stroke:#333,stroke-width:2px;
    style BrokerMQTT fill:#fcf,stroke:#333,stroke-width:2px;
    style Backend fill:#ff9,stroke:#333,stroke-width:2px;
    style Dashboard fill:#9cf,stroke:#333,stroke-width:2px;
```

## üöÄ Como Rodar o Projeto (Localmente ou no Wokwi)

Siga estas etapas para testar o projeto.

---

### üß© Pr√©-requisitos

#### Para o ESP32 (Hardware Real ou Wokwi)

- **Hardware:** ESP32 Dev Kit, Sensor DHT11 ou DHT22, M√≥dulo LDR, jumpers, protoboard.  
- **Software (Real):** IDE do Arduino instalada com suporte para ESP32.  
- **Bibliotecas Arduino:**  
  - PubSubClient  
  - DHT sensor library (Adafruit)  
  - ArduinoJson  
- **Conta Wokwi (Simula√ß√£o):** Gratuita em [wokwi.com](https://wokwi.com)

#### Para o Backend (Python)

- **Python:** vers√£o 3.7+ (baixe em [python.org](https://www.python.org))  
- **pip:** gerenciador de pacotes do Python (j√° incluso normalmente)

---

### üß™ Op√ß√£o 1: Simula√ß√£o com Wokwi (Mais F√°cil)

1. **Abra o Wokwi:** Crie um novo projeto ESP32.  
2. **Adicione Componentes:** DHT22 e LDR Module.  
3. **Fa√ßa as Conex√µes:**

   | Componente | Pino ESP32 | Descri√ß√£o |
   |-------------|------------|------------|
   | 3V3 | Linha + | Alimenta√ß√£o positiva |
   | GND | Linha - | Terra |
   | DHT22 Data | D15 | Dados de temperatura e umidade |
   | LDR AO | D35 | Leitura de luminosidade |


### Adicione os Arquivos de Configura√ß√£o:

libraries.txt
PubSubClient
Adafruit Unified Sensor
DHT sensor library
ArduinoJson
wokwi.toml

[wokwi]
version = 1
firmware = ".pio/build/esp32dev/firmware.bin" # ou caminho padr√£o do Wokwi

[conn]
type = "wifi"
ssid = "Wokwi-GUEST"
password = ""

### üß© Continua√ß√£o ‚Äî Simula√ß√£o no Wokwi

4. **Cole o C√≥digo do ESP32:**  
   Utilize o arquivo `sketch.ino` fornecido (usando **Wokwi-GUEST** e **DHT22**).  
   Certifique-se de ajustar as vari√°veis **`MQTT_BROKER`** e **`MQTT_TOPIC`** corretamente.

5. **Execute o Backend Python** (veja instru√ß√µes abaixo).  

6. **Inicie a Simula√ß√£o:**  
   Clique em ‚ñ∂Ô∏è no Wokwi e verifique o console serial confirmando:  
   - Conex√£o com Wi-Fi  
   - Conex√£o com o Broker MQTT  

---

## üîå Op√ß√£o 2: Hardware Real

1. **Monte o Circuito:**  
   Conecte o **ESP32**, **DHT11/DHT22** e **LDR** conforme o diagrama do projeto.

2. **Abra a IDE Arduino:**
   - Cole o c√≥digo C++ do ESP32.  
   - Altere as vari√°veis:
     - `WIFI_SSID`
     - `WIFI_PASS`
     - `MQTT_BROKER`
     - `MQTT_TOPIC`
   - ‚öôÔ∏è Se estiver usando **DHT11**, altere:
     ```cpp
     #define DHT_TYPE DHT22
     ```
     para:
     ```cpp
     #define DHT_TYPE DHT11
     ```

3. **Instale as Bibliotecas:**  
   Pelo **Gerenciador de Bibliotecas** da IDE Arduino:
   - PubSubClient  
   - DHT sensor library  
   - ArduinoJson  

4. **Compile e Grave o C√≥digo:**  
   - Conecte o ESP32 via USB  
   - Selecione a placa e a porta corretas  
   - Clique em **‚ÄúCarregar‚Äù**  

5. **Abra o Monitor Serial:**  
   - Verifique se o ESP32 conecta corretamente ao **Wi-Fi** e ao **MQTT**  

6. **Execute o Backend Python:**  
   - Siga as instru√ß√µes da pr√≥xima se√ß√£o para iniciar o backend.


### üêç Executando o Backend Python
**1Ô∏è‚É£ Clone o Reposit√≥rio**
git clone URL_DO_SEU_REPOSITORIO
cd NOME_DA_PASTA_DO_PROJETO/backend

**2Ô∏è‚É£ (Opcional) Crie um Ambiente Virtual**
python -m venv .venv
# Ativa√ß√£o Windows:
source .venv/Scripts/activate
# Linux/macOS:
# source .venv/bin/activate

**3Ô∏è‚É£ Instale as Depend√™ncias**
pip install Flask Flask-SocketIO paho-mqtt

**4Ô∏è‚É£ Verifique o Script Python**
Abra listener.py e confirme que MQTT_BROKER e MQTT_TOPIC est√£o iguais aos do ESP32.

**5Ô∏è‚É£ Execute o Script**
python listener.py


## üß≠ Acessando o Dashboard

Com o **backend** rodando, abra no navegador:

üëâ [http://127.0.0.1:5000](http://127.0.0.1:5000)

Voc√™ ver√° o **dashboard** exibindo em tempo real os valores de:
- üå°Ô∏è **Temperatura**
- üíß **Umidade**
- üí° **Luminosidade (%)**

Os dados s√£o atualizados aproximadamente a cada **10 segundos**.

---

## üì° T√≥pico MQTT Principal

fiap/vinheria/dados


### üì¶ Exemplo de Payload JSON enviado pelo ESP32

```json
{
  "temp": 22.5,
  "hum": 55.1,
  "lum": 75,
  "ts": "2025-10-21T19:30:00Z"
}

```

# ‚ö†Ô∏è Solu√ß√£o de Problemas Comuns

## üö´ ESP32 n√£o conecta ao Wi-Fi
- Verifique `WIFI_SSID` e `WIFI_PASS`.
- Confirme se o ESP32 est√° dentro do alcance do roteador.

## üö´ MQTT Timeout
- Confira `MQTT_BROKER` e `MQTT_PORT` (geralmente 1883).
- Verifique se o Broker MQTT est√° online (pode usar o **MQTT Explorer**).
- Desative temporariamente o firewall para teste.

## üö´ Backend n√£o recebe mensagens
- Confirme se o `MQTT_TOPIC` √© id√™ntico no ESP32 e no Python.
- Veja o console serial do ESP32 para confirmar o envio das mensagens.

## üö´ Dashboard n√£o atualiza
- Verifique se o backend Python est√° recebendo mensagens MQTT.
- Abra o console do navegador (F12) e veja erros de **Socket.IO** ou **JavaScript**.

## üí° Luminosidade incorreta
- Verifique se o c√°lculo da luminosidade est√° presente no c√≥digo:

```cpp
ldr_percent = map(ldr_value_raw, 0, 4095, 0, 100);
```

## Confirme que o JSON enviado inclui o campo:

```json
"lum": ldr_percent
```

## üë®‚Äçüíª Desenvolvedor / Contato
**Gabriel Akira Borges Kiyohara ‚Äî FIAP (1ESPJ)**  
üìß E-mail: gakirakiyohara@gmail.com  
üêô GitHub: [Gakira06](https://github.com/Gakira06)

**Gustavo Francisco Santos ‚Äî FIAP (1ESPJ)**  
üìß E-mail: gst.santos01@gmail.com  
üêô GitHub: [gugasantos24](https://github.com/gugasantos24)

**Mauro Carlos ‚Äî FIAP (1ESPJ)**

## üìÑ Licen√ßa
Este projeto foi desenvolvido para fins acad√™micos.  
Uso e modifica√ß√£o s√£o permitidos dentro deste contexto.  
Distribui√ß√£o ou uso comercial n√£o autorizado √© proibido.

¬© 2025 Gabriel Akira Borges Kiyohara
